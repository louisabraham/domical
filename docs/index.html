<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>OCaml - iodide</title>
<link rel="stylesheet" type="text/css" href="https://iodide.io/dist/iodide.pyodide-20180623.css">
</head>
<body>
<script id="jsmd" type="text/jsmd">
%% meta
{
  "title": "OCaml",
  "lastSaved": "2018-08-30T16:42:59.630Z",
  "languages": {
    "js": {
      "pluginType": "language",
      "languageId": "js",
      "displayName": "Javascript",
      "codeMirrorMode": "javascript",
      "module": "window",
      "evaluator": "eval",
      "keybinding": "j",
      "url": ""
    },
    "py": {
      "languageId": "py",
      "displayName": "python",
      "codeMirrorMode": "python",
      "keybinding": "p",
      "url": "https://iodide.io/pyodide-demo/pyodide.js",
      "module": "pyodide",
      "evaluator": "runPython",
      "pluginType": "language"
    },
    "ml": {
      "languageId": "ml",
      "displayName": "ocaml",
      "codeMirrorMode": "mllike",
      "keybinding": "o",
      "url": "eval.js",
      "module": "evaluator",
      "evaluator": "execute",
      "pluginType": "language"
    }
  },
  "lastExport": "2018-08-30T16:44:05.697Z"
}

%% md
# Domical 🐪

Domical (anagram of iodcaml) adds support for OCaml in an Iodide notebook, running inside your browser.

**This is early days.  Everything here is subject to change.**

**Also to note: If you have any issues, try disabling any ad or tracking blockers for this site.**

First, let's use a plugin cell to load the OCaml interpreter and tell Iodide about the new cell type.

Use the buttons of the menu bar or use Shift+Enter to execute the current cell.

%% plugin
{
  "languageId": "ml",
  "displayName": "ocaml",
  "codeMirrorMode": "mllike",
  "keybinding": "o",
  "url": "eval.js",
  "module": "evaluator",
  "evaluator": "execute",
  "pluginType": "language"
}

%% resource
style.css

%% md
## Make a OCaml cell.  Import stuff and use it.

Most of the standard library are here and available to use.

%% code {"language":"ml"}
open Printf
let my_data = [ "a"; "beautiful"; "day" ]
let () = List.iter (fun s -> printf "%s\n" s) my_data

%% code {"language":"ml"}
let square x = x * x in
square 3

%% code {"language":"ml"}
let rec fact x =
  if x <= 1 then 1 else x * fact (x - 1);;
fact 5

%% md
## Performance: better than native `ocaml`

Let's solve [World's hardest sudoku](https://www.telegraph.co.uk/news/science/science-news/9359579/Worlds-hardest-sudoku-can-you-crack-it.html) with the [code from the OCaml tutorial](https://ocaml.org/learn/tutorials/99problems.html#97-Sudoku-medium)

%% code {"language":"ml"}
module Board = struct
  type t = int array (* 9×9, row-major representation.  A value of 0
                        means undecided. *)

  let is_valid c = c >= 1

  let get (b: t) (x, y) = b.(x + y * 9)

  let get_as_string (b: t) pos =
    let i = get b pos in
    if is_valid i then string_of_int i else "."

  let with_val (b: t) (x, y) v =
    let b = Array.copy b in
    b.(x + y * 9) <- v;
    b

  let of_list l : t =
    let b = Array.make 81 0 in
    List.iteri (fun y r -> List.iteri (fun x e ->
        b.(x + y * 9) <- if e >= 0 && e <= 9 then e else 0) r) l;
    b

  let print b =
    for y = 0 to 8 do
      for x = 0 to 8 do
        printf (if x = 0 then "%s" else if x mod 3 = 0 then " | %s"
                else "  %s")  (get_as_string b (x, y))
      done;
      if y < 8 then
        if y mod 3 = 2 then printf "\n--------+---------+--------\n"
        else printf "\n        |         |        \n"
      else printf "\n"
    done

  let available b (x, y) =
    let avail = Array.make 10 true in
    for i = 0 to 8 do
      avail.(get b (x, i)) <- false;
      avail.(get b (i, y)) <- false;
    done;
    let sq_x = x - x mod 3 and sq_y = y - y mod 3 in
    for x = sq_x to sq_x + 2 do
      for y = sq_y to sq_y + 2 do
        avail.(get b (x, y)) <- false;
      done;
    done;
    let av = ref [] in
    for i = 1 (* not 0 *) to 9 do if avail.(i) then av := i :: !av done;
    !av

  let next (x,y) = if x < 8 then (x+1, y) else (0, y+1)

  (** Try to fill the undecided entries. *)
  let rec fill b ((x,y) as pos) =
    if y > 8 then Some b (* filled all entries *)
    else if is_valid(get b pos) then fill b (next pos)
    else match available b pos with
      | [] -> None (* no solution *)
      | l -> try_values b pos l
  and try_values b pos = function
    | v :: l ->
      (match fill (with_val b pos v) (next pos) with
       | Some _ as res -> res
       | None -> try_values b pos l)
    | [] -> None
end

let sudoku b = match Board.fill b (0,0) with
  | Some b -> b
  | None -> failwith "sudoku: no solution"


let time f x =
  let t = Sys.time() in
  let fx = f x in
  Printf.printf "Execution time: %fs\n" (Sys.time() -. t);
  fx

%% code {"language":"ml"}
let hardest_board =
  Board.of_list [[8; 0; 0; 0; 0; 0; 0; 0; 0];
                 [0; 0; 3; 6; 0; 0; 0; 0; 0];
                 [0; 7; 0; 0; 9; 0; 2; 0; 0];
                 [0; 5; 0; 0; 0; 7; 0; 0; 0];
                 [0; 0; 0; 0; 4; 5; 7; 0; 0];
                 [0; 0; 0; 1; 0; 0; 0; 3; 0];
                 [0; 0; 1; 0; 0; 0; 0; 6; 8];
                 [0; 0; 8; 5; 0; 0; 0; 1; 0];
                 [0; 9; 0; 0; 0; 0; 4; 0; 0]] in

Board.print (time sudoku hardest_board);;

%% md
Try the code above in the `ocaml` interpreter, on my machine it is more than twice as fast **in the browser**!!!

</script>
<div id='page'></div>
<script src='https://iodide.io/dist/iodide.pyodide-20180623.js'></script>
</body>
</html>